<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raster Algorithms</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            background-color: #f4f4f9;
            height: 100vh;
        }

        #controls {
            width: 280px;
            padding: 20px;
            background-color: #ffffff;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
            flex-shrink: 0;
        }

        #canvas-container {
            flex-grow: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            width: 1160px; 
            height: 680px;
            flex-grow: 0; 
            flex-shrink: 0;
        }

        #raster-canvas {
            background-color: #ffffff;
            border: 1px solid #ccc;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        h2 {
            color: #333;
            margin-top: 0;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }

        .input-group label {
            display: block;
            margin-top: 10px;
            font-weight: bold;
        }

        .input-coords {
            display: grid;
            grid-template-columns: auto 1fr auto 1fr;
            gap: 5px;
            align-items: center;
        }

        .input-coords input {
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 100%;
            box-sizing: border-box;
        }

        .radio-group {
            margin-bottom: 15px;
        }

        .radio-group label {
            display: block;
            margin-bottom: 5px;
        }

        button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
            width: 100%;
            font-size: 16px;
        }

        #draw-button {
            background-color: #0077b6;
            color: white;
        }

        #clear-button {
            background-color: #e63946;
            color: white;
        }

        #scale-info {
            margin-top: 5px;
            font-size: 0.9em;
            color: #666;
        }

        #status-bar {
            background-color: #e9ecef;
            padding: 10px;
            border-top: 1px solid #ccc;
            font-size: 0.9em;
            color: #333;
            margin-top: 10px;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>

<div id="controls">
    <h2>Raster Algorithms</h2>

    <div class="radio-group">
        <label>
            <input type="radio" name="algorithm" value="step" checked> Step-by-Step
        </label>
        <label>
            <input type="radio" name="algorithm" value="dda"> DDA
        </label>
        <label>
            <input type="radio" name="algorithm" value="bresenham_line"> Bresenham (Line)
        </label>
        <label>
            <input type="radio" name="algorithm" value="bresenham_circle"> Bresenham (Circle)
        </label>
    </div>

    <div id="line-inputs-container" class="input-group">
        <h3>Line Coordinates</h3>
        <div class="input-coords">
            <label>X1:</label><input type="number" id="x1" value="-10">
            <label>Y1:</label><input type="number" id="y1" value="-5">
            <label>X2:</label><input type="number" id="x2" value="10">
            <label>Y2:</label><input type="number" id="y2" value="5">
        </div>
    </div>

    <div id="circle-inputs-container" class="input-group hidden">
        <h3>Circle Coordinates</h3>
        <div class="input-coords">
            <label>Xc:</label><input type="number" id="xc" value="0">
            <label>Yc:</label><input type="number" id="yc" value="0">
            <label>R:</label><input type="number" id="r" value="12">
        </div>
    </div>

    <div class="input-group">
        <h3>Scale (Pixels/Unit)</h3>
        <input type="range" id="zoom-slider" min="5" max="50" value="20">
        <div id="scale-info">20 px/unit</div>
    </div>

    <button id="draw-button">Draw</button>
    <button id="clear-button">Clear</button>

</div>

<div id="canvas-container">
    <canvas id="raster-canvas"></canvas>
    <div id="status-bar">Ready</div>
</div>

<script>
    class RasterApp {
        constructor() {
            this.canvas = document.getElementById('raster-canvas');
            this.ctx = this.canvas.getContext('2d');
            this.controls = {
                algRadios: document.querySelectorAll('input[name="algorithm"]'),
                lineInputs: document.getElementById('line-inputs-container'),
                circleInputs: document.getElementById('circle-inputs-container'),
                zoomSlider: document.getElementById('zoom-slider'),
                scaleInfo: document.getElementById('scale-info'),
                drawButton: document.getElementById('draw-button'),
                clearButton: document.getElementById('clear-button'),
                statusBar: document.getElementById('status-bar')
            };

            this.scale = parseFloat(this.controls.zoomSlider.value);
            this.pixels = [];
            this.currentAlg = 'step';

            this.canvasWidth = 0;
            this.canvasHeight = 0;
            this.originX = 0;
            this.originY = 0;

            this.setupListeners();
            this.onAlgChange(); 
            this.onCanvasResize();
        }

        setupListeners() {
            this.controls.algRadios.forEach(radio => {
                radio.addEventListener('change', this.onAlgChange.bind(this));
            });
            this.controls.zoomSlider.addEventListener('input', this.onZoomChange.bind(this));
            this.controls.drawButton.addEventListener('click', this.onDraw.bind(this));
            this.controls.clearButton.addEventListener('click', this.clearCanvas.bind(this));
            window.addEventListener('resize', this.onCanvasResize.bind(this));
        }

        onCanvasResize() {
            this.canvasWidth = this.canvas.clientWidth;
            this.canvasHeight = this.canvas.clientHeight;
            this.canvas.width = this.canvasWidth;
            this.canvas.height = this.canvasHeight;
            this.originX = this.canvasWidth / 2;
            this.originY = this.canvasHeight / 2;
            this.redrawAll();
        }

        onAlgChange() {
            this.currentAlg = document.querySelector('input[name="algorithm"]:checked').value;
            if (this.currentAlg === "bresenham_circle") {
                this.controls.lineInputs.classList.add('hidden');
                this.controls.circleInputs.classList.remove('hidden');
            } else {
                this.controls.circleInputs.classList.add('hidden');
                this.controls.lineInputs.classList.remove('hidden');
            }
        }

        onZoomChange() {
            this.scale = parseFloat(this.controls.zoomSlider.value);
            this.controls.scaleInfo.textContent = `${Math.round(this.scale)} px/unit`;
            this.redrawAll();
        }

        onDraw() {
            this.pixels = [];
            const alg = this.currentAlg;

            try {
                const startTime = performance.now();
                let newPixels = [];

                if (alg === "bresenham_circle") {
                    const xc = parseInt(document.getElementById('xc').value);
                    const yc = parseInt(document.getElementById('yc').value);
                    const r = parseInt(document.getElementById('r').value);
                    if (r < 0) {
                        this.setStatus("Error: Radius cannot be negative.");
                        return;
                    }
                    newPixels = this.bresenhamCircle(xc, yc, r);
                } else {
                    const x1 = parseInt(document.getElementById('x1').value);
                    const y1 = parseInt(document.getElementById('y1').value);
                    const x2 = parseInt(document.getElementById('x2').value);
                    const y2 = parseInt(document.getElementById('y2').value);

                    switch (alg) {
                        case "step":
                            newPixels = this.stepByStepLine(x1, y1, x2, y2);
                            break;
                        case "dda":
                            newPixels = this.ddaLine(x1, y1, x2, y2);
                            break;
                        case "bresenham_line":
                            newPixels = this.bresenhamLine(x1, y1, x2, y2);
                            break;
                    }
                }

                this.pixels = newPixels;
                const endTime = performance.now();
                const executionTime = endTime - startTime;

                this.drawPixels();

                let timeReport = `Time: ${executionTime.toFixed(3)} ms | `;
                timeReport += `Points: ${this.pixels.length} | `;
                timeReport += `Algorithm: ${this.getAlgorithmName(alg)}`;

                this.setStatus(timeReport);
                console.log(timeReport);

            } catch (e) {
                this.setStatus(`Error: Please enter integer numbers. (${e.message})`);
            }
        }

        getAlgorithmName(algCode) {
            const names = {
                "step": "Step-by-Step",
                "dda": "DDA",
                "bresenham_line": "Bresenham (Line)",
                "bresenham_circle": "Bresenham (Circle)"
            };
            return names[algCode] || "Unknown";
        }

        clearCanvas() {
            this.pixels = [];
            this.redrawAll();
            this.setStatus("Canvas cleared.");
        }

        redrawAll() {
            this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
            this.drawGridAndAxes();
            this.drawPixels();
        }

        drawGridAndAxes() {
            const w = this.canvasWidth;
            const h = this.canvasHeight;
            const ox = this.originX;
            const oy = this.originY;
            const s = this.scale;
            const arrowSize = 10; 

            this.ctx.strokeStyle = '#f0f0f0';
            this.ctx.lineWidth = 1;

            let y = oy % s;
            while (y < h) {
                this.ctx.beginPath();
                this.ctx.moveTo(0, y);
                this.ctx.lineTo(w, y);
                this.ctx.stroke();
                y += s;
            }

            let x = ox % s;
            while (x < w) {
                this.ctx.beginPath();
                this.ctx.moveTo(x, 0);
                this.ctx.lineTo(x, h);
                this.ctx.stroke();
                x += s;
            }

            this.ctx.strokeStyle = 'black';
            this.ctx.lineWidth = 2;
            
            // Draw X Axis
            this.ctx.beginPath();
            this.ctx.moveTo(0, oy);
            this.ctx.lineTo(w, oy);
            this.ctx.stroke();

            // Draw Y Axis
            this.ctx.beginPath();
            this.ctx.moveTo(ox, 0);
            this.ctx.lineTo(ox, h);
            this.ctx.stroke();

            // Arrow on X-axis (Right end)
            this.ctx.fillStyle = 'black';
            this.ctx.beginPath();
            this.ctx.moveTo(w, oy);
            this.ctx.lineTo(w - arrowSize, oy - arrowSize / 2);
            this.ctx.lineTo(w - arrowSize, oy + arrowSize / 2);
            this.ctx.closePath();
            this.ctx.fill();

            // Arrow on Y-axis (Top end)
            this.ctx.beginPath();
            this.ctx.moveTo(ox, 0);
            this.ctx.lineTo(ox - arrowSize / 2, arrowSize);
            this.ctx.lineTo(ox + arrowSize / 2, arrowSize);
            this.ctx.closePath();
            this.ctx.fill();


            this.ctx.fillStyle = 'black';
            this.ctx.font = '12px Arial bold';
            this.ctx.fillText("X", w - 20, oy - 10);
            this.ctx.fillText("Y", ox + 10, 20);

            if (s > 10) {
                this.ctx.font = '8px Arial';
                for (let i = 1; ox + i * s < w; i++) {
                    this.ctx.fillText(i, ox + i * s - 3, oy + 12);
                }
                for (let i = -1; ox + i * s > 0; i--) {
                    this.ctx.fillText(i, ox + i * s - 3, oy + 12);
                }
                for (let i = 1; oy - i * s > 0; i++) {
                    this.ctx.fillText(i, ox + 8, oy - i * s + 3);
                }
                for (let i = -1; oy - i * s < h; i--) {
                    this.ctx.fillText(i, ox + 8, oy - i * s + 3);
                }
                this.ctx.font = '8px Arial bold';
                this.ctx.fillText("0", ox + 8, oy + 12);
            }
        }

        plotPixel(x, y, color) {
            const ox = this.originX;
            const oy = this.originY;
            const s = this.scale;

            const center_x = ox + (x * s);
            const center_y = oy - (y * s);

            const x0 = center_x - (s / 2);
            const y0 = center_y - (s / 2);
            const size = s;

            this.ctx.fillStyle = color;
            this.ctx.fillRect(x0, y0, size, size);

            if (s > 25 && this.pixels.length <= 10) {
                this.ctx.fillStyle = 'darkgray';
                this.ctx.font = '7px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(`(${x},${y})`, center_x + s / 2 + 5, center_y);
            }
        }

        drawPixels() {
            this.pixels.forEach(([x, y, color]) => {
                this.plotPixel(x, y, color);
            });
        }

        setStatus(message) {
            this.controls.statusBar.textContent = message;
        }

        stepByStepLine(x1, y1, x2, y2) {
            const pixels = [];
            const color = "#e63946";

            let dx = x2 - x1;
            let dy = y2 - y1;

            if (dx === 0 && dy === 0) {
                pixels.push([x1, y1, color]);
                return pixels;
            }

            if (Math.abs(dx) >= Math.abs(dy)) {
                if (x1 > x2) {
                    [x1, y1, x2, y2] = [x2, y2, x1, y1];
                    dx = x2 - x1;
                    dy = y2 - y1;
                }

                const k = dy / dx;
                const b = y1 - k * x1;

                for (let x = x1; x <= x2; x++) {
                    const y = Math.round(k * x + b);
                    pixels.push([x, y, color]);
                }
            } else {
                if (y1 > y2) {
                    [x1, y1, x2, y2] = [x2, y2, x1, y1];
                    dx = x2 - x1;
                    dy = y2 - y1;
                }

                const k_inv = dx / dy;
                const b_inv = x1 - k_inv * y1;

                for (let y = y1; y <= y2; y++) {
                    const x = Math.round(k_inv * y + b_inv);
                    pixels.push([x, y, color]);
                }
            }

            return pixels;
        }

        ddaLine(x1, y1, x2, y2) {
            const pixels = [];
            const color = "#2a9d8f";

            const dx = x2 - x1;
            const dy = y2 - y1;

            const steps = Math.max(Math.abs(dx), Math.abs(dy));

            if (steps === 0) {
                pixels.push([x1, y1, color]);
                return pixels;
            }

            const x_inc = dx / steps;
            const y_inc = dy / steps;

            let x = parseFloat(x1);
            let y = parseFloat(y1);

            for (let i = 0; i <= steps; i++) {
                pixels.push([Math.round(x), Math.round(y), color]);
                x += x_inc;
                y += y_inc;
            }

            return pixels;
        }

        bresenhamLine(x1, y1, x2, y2) {
            const pixels = [];
            const color = "#0077b6";
            const debugSteps = [];
            
            let dx = Math.abs(x2 - x1);
            let dy = -Math.abs(y2 - y1);

            const sx = x1 < x2 ? 1 : -1;
            const sy = y1 < y2 ? 1 : -1;

            let err = dx + dy;
            let x = x1;
            let y = y1;
            let step = 0;

            while (true) {
                pixels.push([x, y, color]);
                
                // Debug logging
                debugSteps.push(`Step ${step}: point (${x}, ${y}), error = ${err}`);
                
                if (x === x2 && y === y2) {
                    break;
                }

                const e2 = 2 * err;

                if (e2 >= dy) {
                    err += dy;
                    x += sx;
                }

                if (e2 <= dx) {
                    err += dx;
                    y += sy;
                }
                
                step++;
            }
            
            // Console output logic
            if (debugSteps.length > 0) {
                console.log("\n--- Bresenham Line Calculations ---");
                console.log(`Initial points: (${x1}, ${y1}) -> (${x2}, ${y2})`);
                console.log(`dx = ${dx}, dy = ${dy}, sx = ${sx}, sy = ${sy}`);
                console.log("First 5 steps:");
                for (let i = 0; i < Math.min(5, debugSteps.length); i++) {
                    console.log(debugSteps[i]);
                }
                if (debugSteps.length > 5) {
                    console.log(`... and ${debugSteps.length - 5} more steps`);
                }
                console.log(`Total points: ${pixels.length}`);
                console.log("--- End of Report ---");
            }

            return pixels;
        }

        bresenhamCircle(xc, yc, r) {
            const pixels = new Set();
            const color = "#8338ec";

            let x = 0;
            let y = r;
            let d = 3 - 2 * r;

            const plot8Points = (cx, cy, px, py) => {
                const add = (i, j) => pixels.add(`${i},${j},${color}`);
                add(cx + px, cy + py);
                add(cx - px, cy + py);
                add(cx + px, cy - py);
                add(cx - px, cy - py);
                add(cx + py, cy + px);
                add(cx - py, cy + px);
                add(cx + py, cy - px);
                add(cx - py, cy - px);
            };

            while (x <= y) {
                plot8Points(xc, yc, x, y);

                if (d < 0) {
                    d = d + 4 * x + 6;
                } else {
                    d = d + 4 * (x - y) + 10;
                    y -= 1;
                }
                x += 1;
            }

            return Array.from(pixels).map(p => {
                const parts = p.split(',');
                return [parseInt(parts[0]), parseInt(parts[1]), parts[2]];
            });
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        new RasterApp();
    });
</script>
</body>
</html>